原文：https://blog.csdn.net/idaaa/article/details/78155553

个人粘贴参考使用
//die dai
// 迭 代：
int 迭代(int n) // n = 6
{
	int s = 1;
	for (int i = 1; i <= n; i++)
	{
		s *= i;
		//s =   s * i
		//s =   1 * 1
		//s =   1 * 2
		//s =   2 * 3
		//s =   6 * 4
		//s =  24 * 5
		//s = 120 * 6
	}
	//s = 720
	return s;
}
//迭代-总结:
//这里怎么看出来要迭代什么呢?
//注意s这个变量,它一直是以自己或自己的"后代",也就是自己的下一代去跟其他数值"进化".
//int s = 1;     祖先s_Ⅰ代
//s =   1 * 1    祖先s_Ⅰ代-进化
//s =   1 * 2    s_Ⅱ代-进化      祖先s_Ⅰ代-死去
//s =   2 * 3    s_Ⅲ代-进化      s_Ⅱ代-死去
//s =   6 * 4    s_Ⅳ代-进化      s_Ⅲ代-死去
//s =  24 * 5    s_Ⅴ代-进化      s_Ⅳ代-死去
//s = 120 * 6    s_Ⅵ代-进化      s_Ⅴ代-死去
//最后只剩下     s_Ⅵ代!

//递归：
int 递归(int n) // n = 6
{
	//(int n)保存每次进入函数时n参数的递减值拷贝
	//n = 6 5 4 3 2 1
	int s = 1;
	//s = 1 1 1 1 1 1
	if (n > 1) //6,5,4,3,2一共进入5次递归
	{
		//n = 6 5 4 3 2 1
		//s = 1 1 1 1 1 1
		s = 递归(n - 1);
		//因为递归后,所有值都是从最后一次开始算
		//n = 2 3 4 5 6
		//为什么n没有1呢?因为if (n > 1) 当 n=1 时并没有进入此判断语句.
		//s = 1 2 6 24 120
		//为什么s中有个1呢,因为最后当 n=1 if (n > 1) 直接返回s = 1.
		s *= n;
		//按递归后顺序代入s,n
		//s =   s * n 其中n是参数的拷贝
		//s =   1 * 2
		//s =   2 * 3
		//s =   6 * 4
		//s =  24 * 5
		//s = 120 * 6 一共5次
	}
	//n = 1 2 3  4   5   6
	//s = 1 2 6 24 120 720
	return s;
	//这里要是return n;那么n是几呢?答案是6
}
//递归-总结：
//这里怎么看出来s没有"迭代"呢?
//很简单,因为此函数局部变量s,即不是静态局部变量,也不是全局变量.
//所以此函数会生成6个n和s一共12个的变量单独用于计算.
//再回头看看"迭代"函数里 s,n 都是维一的,再加个 i 也是维一的,一共只有3个变量.
//要点:从递归函数被调用的那一刻起,后面的过程全都是从"最内层"(最后一次)开始算.

//递归_迭代：
int 递归_迭代(int n) // n = 6
{
	//通过局部静态变量保存每次更改后的值.
	static int s = 1;
	s *= n;
	//s =   s * n 其中s是静态变量所以会被保存
	//s =   1 * 6
	//s =   6 * 5
	//s =  30 * 4
	//s = 120 * 3
	//s = 360 * 2
	//s = 720 * 1
	if (n > 1)
	{
		递归_迭代(n - 1);
	}
	//s = 720
	return s;
}
//递归_迭代-总结：
//融合两种特性,瞎发挥一下!
